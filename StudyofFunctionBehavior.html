<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>å‡½æ•°å½¢æ€çš„å¥‡å¦™ä¹‹æ—… - å¢å¼ºç‰ˆ</title>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<script>
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$', '$$'], ['\\[', '\\]']]
    }
  };
</script>
<style>
  :root {
    --primary: #6366F1;
    --secondary: #8B5CF6;
    --accent: #EC4899;
    --success: #10B981;
    --warning: #F59E0B;
    --bg-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    --card-gradient: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
    --bg: #F9FAFB;
    --card: #FFFFFF;
    --text: #1F2937;
    --text-light: #6B7280;
    --border: #E5E7EB;
    font-family: "Microsoft YaHei", "PingFang SC", "Segoe UI", Arial, sans-serif;
  }
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body {
    background: var(--bg-gradient);
    color: var(--text);
    line-height: 1.6;
    overflow-x: hidden;
    min-height: 100vh;
  }
  header {
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(10px);
    color: var(--text);
    padding: 2rem;
    text-align: center;
    box-shadow: 0 4px 20px rgba(0,0,0,0.1);
    position: relative;
    overflow: hidden;
  }
  header::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(135deg, rgba(99,102,241,0.1) 0%, rgba(139,92,246,0.1) 100%);
    z-index: -1;
  }
  header h1 {
    font-size: 2.5rem;
    margin-bottom: 0.5rem;
    font-weight: 700;
    background: linear-gradient(135deg, var(--primary), var(--secondary));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }
  header p {
    font-size: 1.1rem;
    color: var(--text-light);
  }
  .help-tooltip {
    position: fixed;
    top: 20px;
    right: 20px;
    background: white;
    padding: 1rem;
    border-radius: 12px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.15);
    z-index: 1000;
    max-width: 300px;
    display: none;
  }
  .help-tooltip.show {
    display: block;
    animation: slideIn 0.3s ease-out;
  }
  @keyframes slideIn {
    from {
      transform: translateX(100%);
      opacity: 0;
    }
    to {
      transform: translateX(0);
      opacity: 1;
    }
  }
  .container {
    display: grid;
    grid-template-columns: 300px 1fr 340px;
    gap: 1.5rem;
    padding: 1.5rem;
    max-width: 1900px;
    margin: 0 auto;
  }
  .panel {
    background: var(--card-gradient);
    border-radius: 16px;
    padding: 1.5rem;
    box-shadow: 0 8px 32px rgba(0,0,0,0.1);
    height: fit-content;
    position: sticky;
    top: 1.5rem;
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255,255,255,0.5);
  }
  .panel h3 {
    color: var(--primary);
    font-size: 1.2rem;
    margin-bottom: 1rem;
    border-bottom: 2px solid var(--border);
    padding-bottom: 0.5rem;
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }
  .control-group {
    margin-bottom: 1.5rem;
  }
  .control-group label {
    display: block;
    font-weight: 600;
    margin-bottom: 0.5rem;
    color: var(--text);
    font-size: 0.9rem;
  }
  .control-group select,
  .control-group input[type="text"] {
    width: 100%;
    padding: 0.7rem;
    border: 2px solid var(--border);
    border-radius: 10px;
    font-size: 0.95rem;
    transition: all 0.3s;
    background: white;
  }
  .control-group select:focus,
  .control-group input[type="text"]:focus {
    outline: none;
    border-color: var(--primary);
    box-shadow: 0 0 0 3px rgba(99,102,241,0.1);
  }
  .slider-container {
    margin: 1rem 0;
  }
  .slider-label {
    display: flex;
    justify-content: space-between;
    margin-bottom: 0.3rem;
    font-size: 0.85rem;
    color: var(--text-light);
  }
  .slider-label .value {
    font-weight: 600;
    color: var(--primary);
    font-family: "Courier New", monospace;
  }
  input[type="range"] {
    width: 100%;
    height: 8px;
    border-radius: 4px;
    background: linear-gradient(to right, var(--border), var(--primary));
    outline: none;
    -webkit-appearance: none;
    transition: all 0.3s;
  }
  input[type="range"]:hover {
    background: linear-gradient(to right, var(--border), var(--secondary));
  }
  input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: var(--primary);
    cursor: pointer;
    transition: all 0.2s;
    box-shadow: 0 2px 8px rgba(99,102,241,0.3);
  }
  input[type="range"]::-webkit-slider-thumb:hover {
    transform: scale(1.3);
    box-shadow: 0 4px 12px rgba(99,102,241,0.5);
  }
  input[type="range"]::-moz-range-thumb {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: var(--primary);
    cursor: pointer;
    border: none;
    box-shadow: 0 2px 8px rgba(99,102,241,0.3);
  }
  .btn {
    background: linear-gradient(135deg, var(--primary), var(--secondary));
    color: white;
    border: none;
    padding: 0.8rem 1.2rem;
    border-radius: 10px;
    cursor: pointer;
    font-size: 0.95rem;
    font-weight: 600;
    transition: all 0.3s;
    width: 100%;
    margin-top: 0.5rem;
    box-shadow: 0 4px 12px rgba(99,102,241,0.3);
  }
  .btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(99,102,241,0.4);
  }
  .btn:active {
    transform: translateY(0);
  }
  .btn.secondary {
    background: linear-gradient(135deg, var(--text-light), #4B5563);
  }
  .btn.danger {
    background: linear-gradient(135deg, var(--accent), #DB2777);
  }
  .btn.success {
    background: linear-gradient(135deg, var(--success), #059669);
  }
  .btn.warning {
    background: linear-gradient(135deg, var(--warning), #D97706);
  }
  .preset-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 0.5rem;
    margin-top: 0.5rem;
  }
  .preset-btn {
    background: white;
    border: 2px solid var(--primary);
    color: var(--primary);
    padding: 0.5rem 0.8rem;
    border-radius: 8px;
    cursor: pointer;
    font-size: 0.85rem;
    transition: all 0.2s;
    font-weight: 500;
  }
  .preset-btn:hover {
    background: var(--primary);
    color: white;
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(99,102,241,0.3);
  }
  .canvas-wrapper {
    background: var(--card-gradient);
    border-radius: 16px;
    padding: 1.5rem;
    box-shadow: 0 8px 32px rgba(0,0,0,0.1);
    position: relative;
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255,255,255,0.5);
  }
  .canvas-container {
    position: relative;
    background: white;
    border: 3px solid var(--border);
    border-radius: 12px;
    overflow: hidden;
    cursor: crosshair;
    box-shadow: inset 0 2px 10px rgba(0,0,0,0.05);
  }
  #mainCanvas {
    display: block;
    width: 100%;
    height: auto;
    touch-action: none;
  }
  .canvas-controls {
    position: absolute;
    top: 20px;
    right: 20px;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    z-index: 10;
  }
  .canvas-btn {
    width: 44px;
    height: 44px;
    background: white;
    border: 2px solid var(--primary);
    border-radius: 10px;
    cursor: pointer;
    font-size: 1.3rem;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
  }
  .canvas-btn:hover {
    background: var(--primary);
    color: white;
    transform: scale(1.1) rotate(5deg);
  }
  .info-panel {
    background: var(--card-gradient);
    border-radius: 16px;
    padding: 1.5rem;
    box-shadow: 0 8px 32px rgba(0,0,0,0.1);
    height: fit-content;
    position: sticky;
    top: 1.5rem;
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255,255,255,0.5);
  }
  .function-item {
    background: linear-gradient(135deg, #F3F4F6, #E5E7EB);
    border-left: 4px solid var(--primary);
    padding: 1rem;
    margin-bottom: 1rem;
    border-radius: 8px;
    transition: all 0.3s;
    position: relative;
    overflow: hidden;
  }
  .function-item::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
    transition: left 0.5s;
  }
  .function-item:hover::before {
    left: 100%;
  }
  .function-item:hover {
    transform: translateX(4px);
    box-shadow: 0 4px 12px rgba(99,102,241,0.2);
  }
  .function-item.active {
    border-left-color: var(--success);
    background: linear-gradient(135deg, #ECFDF5, #D1FAE5);
  }
  .function-expression {
    font-family: "Courier New", monospace;
    font-size: 1rem;
    color: var(--text);
    margin: 0.5rem 0;
    padding: 0.6rem;
    background: white;
    border-radius: 6px;
    border: 1px solid var(--border);
  }
  .feature-points {
    margin-top: 1rem;
    max-height: 300px;
    overflow-y: auto;
  }
  .feature-point {
    padding: 0.6rem;
    margin: 0.3rem 0;
    background: linear-gradient(135deg, #FEF3C7, #FDE68A);
    border-radius: 8px;
    font-size: 0.85rem;
    border-left: 3px solid var(--warning);
    animation: pulse 2s infinite;
  }
  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.8; }
  }
  .coordinate-display {
    position: absolute;
    bottom: 20px;
    left: 20px;
    background: rgba(0,0,0,0.85);
    color: white;
    padding: 0.6rem 1rem;
    border-radius: 8px;
    font-family: "Courier New", monospace;
    font-size: 0.9rem;
    pointer-events: none;
    display: none;
    backdrop-filter: blur(10px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
  }
  .color-picker {
    width: 100%;
    height: 45px;
    border: 2px solid var(--border);
    border-radius: 10px;
    cursor: pointer;
    transition: all 0.3s;
  }
  .color-picker:hover {
    transform: scale(1.05);
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
  }
  .function-list {
    max-height: 400px;
    overflow-y: auto;
  }
  .checkbox-group {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin: 0.5rem 0;
    padding: 0.4rem;
    border-radius: 6px;
    transition: background 0.2s;
  }
  .checkbox-group:hover {
    background: rgba(99,102,241,0.05);
  }
  .checkbox-group input[type="checkbox"] {
    width: 20px;
    height: 20px;
    cursor: pointer;
    accent-color: var(--primary);
  }
  .legend {
    display: flex;
    flex-wrap: wrap;
    gap: 1rem;
    margin-top: 1rem;
    padding: 1rem;
    background: linear-gradient(135deg, #F9FAFB, #F3F4F6);
    border-radius: 10px;
  }
  .legend-item {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.3rem 0.6rem;
    background: white;
    border-radius: 6px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
  }
  .legend-color {
    width: 24px;
    height: 4px;
    border-radius: 2px;
  }
  .integral-controls {
    background: linear-gradient(135deg, #EFF6FF, #DBEAFE);
    padding: 1rem;
    border-radius: 10px;
    margin-top: 1rem;
    border: 2px dashed var(--primary);
  }
  .integral-display {
    margin-top: 0.5rem;
    padding: 0.5rem;
    background: white;
    border-radius: 6px;
    font-family: "Courier New", monospace;
    font-size: 0.9rem;
    color: var(--primary);
    font-weight: 600;
  }
  .animation-controls {
    background: linear-gradient(135deg, #F0FDF4, #D1FAE5);
    padding: 1rem;
    border-radius: 10px;
    margin-top: 1rem;
    border: 2px dashed var(--success);
  }
  .animation-progress {
    width: 100%;
    height: 8px;
    background: var(--border);
    border-radius: 4px;
    margin-top: 0.5rem;
    overflow: hidden;
  }
  .animation-progress-bar {
    height: 100%;
    background: linear-gradient(90deg, var(--success), var(--primary));
    width: 0%;
    transition: width 0.1s;
    border-radius: 4px;
  }
  @keyframes pointPulse {
    0%, 100% { transform: scale(1); opacity: 1; }
    50% { transform: scale(1.5); opacity: 0.7; }
  }
  .animated-point {
    animation: pointPulse 1.5s infinite;
  }
  @media (max-width: 1400px) {
    .container {
      grid-template-columns: 280px 1fr 320px;
    }
  }
  @media (max-width: 1024px) {
    .container {
      grid-template-columns: 1fr;
    }
    .panel, .info-panel {
      position: static;
    }
    .canvas-wrapper {
      order: -1;
    }
  }
  .help-btn {
    position: fixed;
    bottom: 20px;
    right: 20px;
    width: 50px;
    height: 50px;
    border-radius: 50%;
    background: linear-gradient(135deg, var(--primary), var(--secondary));
    color: white;
    border: none;
    font-size: 1.5rem;
    cursor: pointer;
    box-shadow: 0 4px 20px rgba(99,102,241,0.4);
    transition: all 0.3s;
    z-index: 999;
  }
  .help-btn:hover {
    transform: scale(1.1) rotate(360deg);
    box-shadow: 0 6px 30px rgba(99,102,241,0.6);
  }
</style>
</head>
<body>
<header>
  <h1>ğŸŒŸ å‡½æ•°å½¢æ€çš„å¥‡å¦™ä¹‹æ—… - å¢å¼ºç‰ˆ</h1>
  <p>æ¢ç´¢å‡½æ•°å›¾åƒéšå‚æ•°å˜åŒ–çš„åŠ¨æ€ä¹‹ç¾ | æ”¯æŒå¯¼æ•°ã€ç§¯åˆ†ã€åŠ¨ç”»æ¼”ç¤º</p>
</header>

<button class="help-btn" onclick="toggleHelp()" title="æ“ä½œæŒ‡å¼•">?</button>
<div class="help-tooltip" id="helpTooltip">
  <h4 style="margin-bottom: 0.5rem; color: var(--primary);">ğŸ“– æ“ä½œæŒ‡å¼•</h4>
  <ul style="font-size: 0.85rem; line-height: 1.8; color: var(--text-light);">
    <li><strong>é¼ æ ‡æ‹–æ‹½</strong>ï¼šå¹³ç§»ç”»å¸ƒ</li>
    <li><strong>æ»šè½®</strong>ï¼šç¼©æ”¾è§†å›¾</li>
    <li><strong>æ–¹å‘é”®</strong>ï¼šè°ƒèŠ‚å½“å‰å‚æ•°</li>
    <li><strong>Ctrl+S</strong>ï¼šä¿å­˜æˆªå›¾</li>
    <li><strong>ç©ºæ ¼é”®</strong>ï¼šæ’­æ”¾/æš‚åœåŠ¨ç”»</li>
  </ul>
</div>

<div class="container">
  <!-- å·¦ä¾§æ§åˆ¶é¢æ¿ -->
  <div class="panel">
    <h3>ğŸ›ï¸ æ§åˆ¶é¢æ¿</h3>
    
    <div class="control-group">
      <label>å‡½æ•°ç±»å‹</label>
      <select id="functionType" onchange="changeFunctionType()">
        <option value="linear">ä¸€æ¬¡å‡½æ•° y = ax + b</option>
        <option value="quadratic">äºŒæ¬¡å‡½æ•° y = axÂ² + bx + c</option>
        <option value="exponential">æŒ‡æ•°å‡½æ•° y = aÂ·e^(bx) + c</option>
        <option value="logarithmic">å¯¹æ•°å‡½æ•° y = aÂ·ln(bx) + c</option>
        <option value="sinusoidal">æ­£å¼¦å‡½æ•° y = aÂ·sin(bx + c) + d</option>
        <option value="cosine">ä½™å¼¦å‡½æ•° y = aÂ·cos(bx + c) + d</option>
        <option value="rational">æœ‰ç†å‡½æ•° y = (ax + b) / (cx + d)</option>
        <option value="power">å¹‚å‡½æ•° y = aÂ·x^b + c</option>
      </select>
    </div>

    <div class="control-group">
      <label>é¢„è®¾ç¤ºä¾‹</label>
      <div class="preset-grid" id="presetGrid"></div>
    </div>

    <div id="parameterControls"></div>

    <div class="control-group">
      <label>å‡½æ•°é¢œè‰²</label>
      <input type="color" id="functionColor" class="color-picker" value="#6366F1" onchange="updatePlot()">
    </div>

    <div class="control-group">
      <label>æ˜¾ç¤ºé€‰é¡¹</label>
      <div class="checkbox-group">
        <input type="checkbox" id="showGrid" checked onchange="updatePlot()">
        <label for="showGrid">æ˜¾ç¤ºç½‘æ ¼</label>
      </div>
      <div class="checkbox-group">
        <input type="checkbox" id="showAxes" checked onchange="updatePlot()">
        <label for="showAxes">æ˜¾ç¤ºåæ ‡è½´</label>
      </div>
      <div class="checkbox-group">
        <input type="checkbox" id="showPoints" checked onchange="updatePlot()">
        <label for="showPoints">æ ‡æ³¨ç‰¹å¾ç‚¹</label>
      </div>
      <div class="checkbox-group">
        <input type="checkbox" id="showDerivative" onchange="updatePlot()">
        <label for="showDerivative">æ˜¾ç¤ºå¯¼æ•°å›¾åƒ</label>
      </div>
      <div class="checkbox-group">
        <input type="checkbox" id="showIntegral" onchange="toggleIntegral()">
        <label for="showIntegral">æ˜¾ç¤ºç§¯åˆ†é¢ç§¯</label>
      </div>
      <div class="checkbox-group">
        <input type="checkbox" id="showLabels" checked onchange="updatePlot()">
        <label for="showLabels">æ˜¾ç¤ºæ ‡ç­¾</label>
      </div>
    </div>

    <div id="integralControls" style="display: none;"></div>

    <div class="animation-controls">
      <label style="display: block; margin-bottom: 0.5rem; font-weight: 600;">åŠ¨ç”»æ¼”ç¤º</label>
      <button class="btn success" id="animationBtn" onclick="toggleAnimation()">â–¶ï¸ å¼€å§‹åŠ¨ç”»</button>
      <div class="animation-progress" id="animationProgress" style="display: none;">
        <div class="animation-progress-bar" id="animationProgressBar"></div>
      </div>
    </div>

    <button class="btn" onclick="addFunction()">â• æ·»åŠ å‡½æ•°</button>
    <button class="btn secondary" onclick="resetView()">ğŸ”„ é‡ç½®è§†å›¾</button>
    <button class="btn warning" onclick="saveScreenshot()">ğŸ“¸ ä¿å­˜æˆªå›¾</button>
    <button class="btn danger" onclick="clearAll()">ğŸ—‘ï¸ æ¸…é™¤æ‰€æœ‰</button>
  </div>

  <!-- ä¸­é—´ç”»å¸ƒåŒºåŸŸ -->
  <div class="canvas-wrapper">
    <div class="canvas-container" id="canvasContainer">
      <div class="canvas-controls">
        <div class="canvas-btn" onclick="zoomIn()" title="æ”¾å¤§">+</div>
        <div class="canvas-btn" onclick="zoomOut()" title="ç¼©å°">âˆ’</div>
        <div class="canvas-btn" onclick="resetView()" title="é‡ç½®">âŒ‚</div>
      </div>
      <canvas id="mainCanvas" width="900" height="650"></canvas>
      <div class="coordinate-display" id="coordinateDisplay"></div>
    </div>
    <div class="legend" id="legend"></div>
  </div>

  <!-- å³ä¾§ä¿¡æ¯é¢æ¿ -->
  <div class="info-panel">
    <h3>ğŸ“Š å‡½æ•°ä¿¡æ¯</h3>
    <div class="function-list" id="functionList"></div>
    <div class="feature-points" id="featurePoints"></div>
  </div>
</div>

<script>
  // å…¨å±€çŠ¶æ€
  let functions = [];
  let viewState = {
    scale: 50,
    offsetX: 0,
    offsetY: 0,
    isDragging: false,
    lastX: 0,
    lastY: 0
  };
  let animationFrame = null;
  let isAnimating = false;
  let animationInterval = null;
  let currentParamIndex = 0;
  let animationDirection = 1;

  // é¢„è®¾ç¤ºä¾‹é…ç½®
  const presets = {
    linear: [
      { name: 'æ ‡å‡†ç›´çº¿', params: { a: 1, b: 0 } },
      { name: 'æ­£æ–œç‡', params: { a: 2, b: 0 } },
      { name: 'è´Ÿæ–œç‡', params: { a: -1, b: 0 } },
      { name: 'æˆªè·çº¿', params: { a: 1, b: 3 } }
    ],
    quadratic: [
      { name: 'æ ‡å‡†æŠ›ç‰©çº¿', params: { a: 1, b: 0, c: 0 } },
      { name: 'å¼€å£å‘ä¸Š', params: { a: 2, b: -3, c: 1 } },
      { name: 'å¼€å£å‘ä¸‹', params: { a: -1, b: 2, c: 3 } },
      { name: 'é¡¶ç‚¹åç§»', params: { a: 1, b: -4, c: 4 } }
    ],
    exponential: [
      { name: 'æ ‡å‡†æŒ‡æ•°', params: { a: 1, b: 1, c: 0 } },
      { name: 'å¢é•¿æŒ‡æ•°', params: { a: 2, b: 1.5, c: 0 } },
      { name: 'è¡°å‡æŒ‡æ•°', params: { a: 1, b: -0.5, c: 0 } },
      { name: 'åç§»æŒ‡æ•°', params: { a: 1, b: 1, c: -2 } }
    ],
    logarithmic: [
      { name: 'æ ‡å‡†å¯¹æ•°', params: { a: 1, b: 1, c: 0 } },
      { name: 'å¿«é€Ÿå¢é•¿', params: { a: 2, b: 1, c: 0 } },
      { name: 'ç¼“æ…¢å¢é•¿', params: { a: 0.5, b: 1, c: 0 } },
      { name: 'å‘ä¸‹åç§»', params: { a: 1, b: 1, c: -3 } }
    ],
    sinusoidal: [
      { name: 'æ ‡å‡†æ­£å¼¦', params: { a: 1, b: 1, c: 0, d: 0 } },
      { name: 'é«˜æŒ¯å¹…', params: { a: 2, b: 1, c: 0, d: 0 } },
      { name: 'é«˜é¢‘ç‡', params: { a: 1, b: 3, c: 0, d: 0 } },
      { name: 'ç›¸ä½åç§»', params: { a: 1, b: 1, c: Math.PI/2, d: 0 } }
    ],
    cosine: [
      { name: 'æ ‡å‡†ä½™å¼¦', params: { a: 1, b: 1, c: 0, d: 0 } },
      { name: 'é«˜æŒ¯å¹…', params: { a: 2, b: 1, c: 0, d: 0 } },
      { name: 'é«˜é¢‘ç‡', params: { a: 1, b: 2, c: 0, d: 0 } },
      { name: 'å‚ç›´åç§»', params: { a: 1, b: 1, c: 0, d: 2 } }
    ],
    rational: [
      { name: 'æ ‡å‡†æœ‰ç†', params: { a: 1, b: 0, c: 1, d: 0 } },
      { name: 'åŒæ›²çº¿', params: { a: 1, b: 1, c: 1, d: -1 } },
      { name: 'å¤æ‚å½¢å¼', params: { a: 2, b: 1, c: 1, d: 2 } }
    ],
    power: [
      { name: 'å¹³æ–¹å‡½æ•°', params: { a: 1, b: 2, c: 0 } },
      { name: 'ç«‹æ–¹å‡½æ•°', params: { a: 1, b: 3, c: 0 } },
      { name: 'å¹³æ–¹æ ¹', params: { a: 1, b: 0.5, c: 0 } },
      { name: 'å€’æ•°å‡½æ•°', params: { a: 1, b: -1, c: 0 } }
    ]
  };

  // å‡½æ•°å®šä¹‰ï¼ˆä¿æŒåŸæœ‰å®šä¹‰ï¼‰
  const functionDefinitions = {
    linear: {
      name: 'ä¸€æ¬¡å‡½æ•°',
      formula: 'y = ax + b',
      params: [
        { name: 'a', label: 'æ–œç‡ a', min: -5, max: 5, step: 0.1, value: 1 },
        { name: 'b', label: 'æˆªè· b', min: -5, max: 5, step: 0.1, value: 0 }
      ],
      eval: (x, params) => params.a * x + params.b,
      derivative: (x, params) => params.a,
      features: (params) => {
        const zero = params.a !== 0 ? -params.b / params.a : null;
        return zero !== null ? [{ type: 'é›¶ç‚¹', x: zero, y: 0 }] : [];
      }
    },
    quadratic: {
      name: 'äºŒæ¬¡å‡½æ•°',
      formula: 'y = axÂ² + bx + c',
      params: [
        { name: 'a', label: 'ç³»æ•° a', min: -3, max: 3, step: 0.1, value: 1 },
        { name: 'b', label: 'ç³»æ•° b', min: -5, max: 5, step: 0.1, value: 0 },
        { name: 'c', label: 'ç³»æ•° c', min: -5, max: 5, step: 0.1, value: 0 }
      ],
      eval: (x, params) => params.a * x * x + params.b * x + params.c,
      derivative: (x, params) => 2 * params.a * x + params.b,
      features: (params) => {
        const points = [];
        if (params.a !== 0) {
          const vertexX = -params.b / (2 * params.a);
          const vertexY = params.a * vertexX * vertexX + params.b * vertexX + params.c;
          points.push({ type: params.a > 0 ? 'æå°å€¼' : 'æå¤§å€¼', x: vertexX, y: vertexY });
          
          const discriminant = params.b * params.b - 4 * params.a * params.c;
          if (discriminant >= 0) {
            const sqrtD = Math.sqrt(discriminant);
            const x1 = (-params.b - sqrtD) / (2 * params.a);
            const x2 = (-params.b + sqrtD) / (2 * params.a);
            points.push({ type: 'é›¶ç‚¹', x: x1, y: 0 });
            if (Math.abs(x1 - x2) > 0.001) {
              points.push({ type: 'é›¶ç‚¹', x: x2, y: 0 });
            }
          }
        }
        return points;
      }
    },
    exponential: {
      name: 'æŒ‡æ•°å‡½æ•°',
      formula: 'y = aÂ·e^(bx) + c',
      params: [
        { name: 'a', label: 'ç³»æ•° a', min: -3, max: 3, step: 0.1, value: 1 },
        { name: 'b', label: 'æŒ‡æ•° b', min: -2, max: 2, step: 0.1, value: 1 },
        { name: 'c', label: 'å¸¸æ•° c', min: -5, max: 5, step: 0.1, value: 0 }
      ],
      eval: (x, params) => params.a * Math.exp(params.b * x) + params.c,
      derivative: (x, params) => params.a * params.b * Math.exp(params.b * x),
      features: (params) => {
        const points = [];
        if (params.a !== 0 && params.b !== 0) {
          const zero = Math.log(-params.c / params.a) / params.b;
          if (isFinite(zero) && Math.abs(params.a * Math.exp(params.b * zero) + params.c) < 0.01) {
            points.push({ type: 'é›¶ç‚¹', x: zero, y: 0 });
          }
        }
        return points;
      }
    },
    logarithmic: {
      name: 'å¯¹æ•°å‡½æ•°',
      formula: 'y = aÂ·ln(bx) + c',
      params: [
        { name: 'a', label: 'ç³»æ•° a', min: -3, max: 3, step: 0.1, value: 1 },
        { name: 'b', label: 'ç³»æ•° b', min: 0.1, max: 5, step: 0.1, value: 1 },
        { name: 'c', label: 'å¸¸æ•° c', min: -5, max: 5, step: 0.1, value: 0 }
      ],
      eval: (x, params) => {
        if (params.b * x <= 0) return NaN;
        return params.a * Math.log(params.b * x) + params.c;
      },
      derivative: (x, params) => {
        if (params.b * x <= 0) return NaN;
        return params.a * params.b / (params.b * x);
      },
      features: (params) => {
        const points = [];
        if (params.a !== 0 && params.b > 0) {
          const zero = Math.exp(-params.c / params.a) / params.b;
          if (isFinite(zero) && zero > 0) {
            points.push({ type: 'é›¶ç‚¹', x: zero, y: 0 });
          }
        }
        return points;
      }
    },
    sinusoidal: {
      name: 'æ­£å¼¦å‡½æ•°',
      formula: 'y = aÂ·sin(bx + c) + d',
      params: [
        { name: 'a', label: 'æŒ¯å¹… a', min: -3, max: 3, step: 0.1, value: 1 },
        { name: 'b', label: 'é¢‘ç‡ b', min: 0.1, max: 3, step: 0.1, value: 1 },
        { name: 'c', label: 'ç›¸ä½ c', min: -Math.PI, max: Math.PI, step: 0.1, value: 0 },
        { name: 'd', label: 'åç§» d', min: -5, max: 5, step: 0.1, value: 0 }
      ],
      eval: (x, params) => params.a * Math.sin(params.b * x + params.c) + params.d,
      derivative: (x, params) => params.a * params.b * Math.cos(params.b * x + params.c),
      features: (params) => {
        const points = [];
        const period = 2 * Math.PI / params.b;
        for (let i = -2; i <= 2; i++) {
          const x = (i * Math.PI - params.c) / params.b;
          const y = params.a * Math.sin(params.b * x + params.c) + params.d;
          points.push({ type: i % 2 === 0 ? 'é›¶ç‚¹' : 'æå€¼', x: x, y: y });
        }
        return points;
      }
    },
    cosine: {
      name: 'ä½™å¼¦å‡½æ•°',
      formula: 'y = aÂ·cos(bx + c) + d',
      params: [
        { name: 'a', label: 'æŒ¯å¹… a', min: -3, max: 3, step: 0.1, value: 1 },
        { name: 'b', label: 'é¢‘ç‡ b', min: 0.1, max: 3, step: 0.1, value: 1 },
        { name: 'c', label: 'ç›¸ä½ c', min: -Math.PI, max: Math.PI, step: 0.1, value: 0 },
        { name: 'd', label: 'åç§» d', min: -5, max: 5, step: 0.1, value: 0 }
      ],
      eval: (x, params) => params.a * Math.cos(params.b * x + params.c) + params.d,
      derivative: (x, params) => -params.a * params.b * Math.sin(params.b * x + params.c),
      features: (params) => {
        const points = [];
        for (let i = -2; i <= 2; i++) {
          const x = ((i + 0.5) * Math.PI - params.c) / params.b;
          const y = params.a * Math.cos(params.b * x + params.c) + params.d;
          points.push({ type: i % 2 === 0 ? 'æå€¼' : 'é›¶ç‚¹', x: x, y: y });
        }
        return points;
      }
    },
    rational: {
      name: 'æœ‰ç†å‡½æ•°',
      formula: 'y = (ax + b) / (cx + d)',
      params: [
        { name: 'a', label: 'åˆ†å­ç³»æ•° a', min: -3, max: 3, step: 0.1, value: 1 },
        { name: 'b', label: 'åˆ†å­å¸¸æ•° b', min: -5, max: 5, step: 0.1, value: 0 },
        { name: 'c', label: 'åˆ†æ¯ç³»æ•° c', min: -3, max: 3, step: 0.1, value: 1 },
        { name: 'd', label: 'åˆ†æ¯å¸¸æ•° d', min: -5, max: 5, step: 0.1, value: 0 }
      ],
      eval: (x, params) => {
        const denom = params.c * x + params.d;
        if (Math.abs(denom) < 0.001) return NaN;
        return (params.a * x + params.b) / denom;
      },
      derivative: (x, params) => {
        const denom = params.c * x + params.d;
        if (Math.abs(denom) < 0.001) return NaN;
        return (params.a * params.d - params.b * params.c) / (denom * denom);
      },
      features: (params) => {
        const points = [];
        if (params.a !== 0) {
          const zero = -params.b / params.a;
          points.push({ type: 'é›¶ç‚¹', x: zero, y: 0 });
        }
        if (params.c !== 0) {
          const asymptote = -params.d / params.c;
          points.push({ type: 'æ¸è¿‘çº¿', x: asymptote, y: NaN });
        }
        return points;
      }
    },
    power: {
      name: 'å¹‚å‡½æ•°',
      formula: 'y = aÂ·x^b + c',
      params: [
        { name: 'a', label: 'ç³»æ•° a', min: -3, max: 3, step: 0.1, value: 1 },
        { name: 'b', label: 'æŒ‡æ•° b', min: -3, max: 3, step: 0.1, value: 2 },
        { name: 'c', label: 'å¸¸æ•° c', min: -5, max: 5, step: 0.1, value: 0 }
      ],
      eval: (x, params) => {
        if (x < 0 && params.b !== Math.floor(params.b)) return NaN;
        return params.a * Math.pow(x, params.b) + params.c;
      },
      derivative: (x, params) => {
        if (x < 0 && params.b !== Math.floor(params.b)) return NaN;
        return params.a * params.b * Math.pow(x, params.b - 1);
      },
      features: (params) => {
        const points = [];
        if (params.a !== 0 && params.b > 0) {
          const zero = Math.pow(-params.c / params.a, 1 / params.b);
          if (isFinite(zero) && !isNaN(zero)) {
            points.push({ type: 'é›¶ç‚¹', x: zero, y: 0 });
          }
        }
        if (params.b > 1 && params.a !== 0) {
          points.push({ type: 'æå€¼', x: 0, y: params.c });
        }
        return points;
      }
    }
  };

  // åˆå§‹åŒ–
  function init() {
    changeFunctionType();
    setupCanvas();
    setupKeyboard();
    addFunction();
  }

  // è®¾ç½®é”®ç›˜å¿«æ·é”®
  function setupKeyboard() {
    document.addEventListener('keydown', (e) => {
      if (functions.length === 0) return;
      
      const currentFunc = functions[functions.length - 1];
      const def = functionDefinitions[currentFunc.type];
      const params = def.params;
      
      if (params.length === 0) return;
      
      let paramIndex = currentParamIndex % params.length;
      const param = params[paramIndex];
      const currentValue = currentFunc.params[param.name];
      let newValue = currentValue;
      
      if (e.key === 'ArrowUp' || e.key === 'ArrowRight') {
        newValue = Math.min(param.max, currentValue + param.step);
        e.preventDefault();
      } else if (e.key === 'ArrowDown' || e.key === 'ArrowLeft') {
        newValue = Math.max(param.min, currentValue - param.step);
        e.preventDefault();
      } else if (e.key === ' ' || e.key === 'Space') {
        e.preventDefault();
        toggleAnimation();
      } else if (e.ctrlKey && e.key === 's') {
        e.preventDefault();
        saveScreenshot();
      } else {
        return;
      }
      
      if (newValue !== currentValue) {
        currentFunc.params[param.name] = newValue;
        const slider = document.getElementById(`param_${param.name}`);
        if (slider) {
          slider.value = newValue;
          document.getElementById(`value_${param.name}`).textContent = newValue.toFixed(2);
        }
        updatePlot();
      }
    });
  }

  // åˆ‡æ¢å¸®åŠ©æç¤º
  function toggleHelp() {
    const tooltip = document.getElementById('helpTooltip');
    tooltip.classList.toggle('show');
  }

  // è®¾ç½®ç”»å¸ƒäº‹ä»¶
  function setupCanvas() {
    const canvas = document.getElementById('mainCanvas');
    const container = document.getElementById('canvasContainer');
    
    // é¼ æ ‡äº‹ä»¶
    canvas.addEventListener('mousedown', (e) => {
      viewState.isDragging = true;
      viewState.lastX = e.offsetX;
      viewState.lastY = e.offsetY;
    });
    
    canvas.addEventListener('mousemove', (e) => {
      if (viewState.isDragging) {
        viewState.offsetX += (e.offsetX - viewState.lastX) / viewState.scale;
        viewState.offsetY -= (e.offsetY - viewState.lastY) / viewState.scale;
        viewState.lastX = e.offsetX;
        viewState.lastY = e.offsetY;
        updatePlot();
      } else {
        showCoordinates(e.offsetX, e.offsetY);
      }
    });
    
    canvas.addEventListener('mouseup', () => {
      viewState.isDragging = false;
    });
    
    canvas.addEventListener('mouseleave', () => {
      viewState.isDragging = false;
      document.getElementById('coordinateDisplay').style.display = 'none';
    });
    
    canvas.addEventListener('wheel', (e) => {
      e.preventDefault();
      const delta = e.deltaY > 0 ? 0.9 : 1.1;
      viewState.scale *= delta;
      viewState.scale = Math.max(10, Math.min(200, viewState.scale));
      updatePlot();
    });
    
    // è§¦æ‘¸äº‹ä»¶ï¼ˆç§»åŠ¨ç«¯ä¼˜åŒ–ï¼‰
    let touchStartX = 0, touchStartY = 0;
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      touchStartX = touch.clientX;
      touchStartY = touch.clientY;
      viewState.isDragging = true;
    });
    
    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      if (viewState.isDragging && e.touches.length === 1) {
        const touch = e.touches[0];
        const dx = touch.clientX - touchStartX;
        const dy = touch.clientY - touchStartY;
        viewState.offsetX += dx / viewState.scale;
        viewState.offsetY -= dy / viewState.scale;
        touchStartX = touch.clientX;
        touchStartY = touch.clientY;
        updatePlot();
      } else if (e.touches.length === 2) {
        // åŒæŒ‡ç¼©æ”¾
        const touch1 = e.touches[0];
        const touch2 = e.touches[1];
        const distance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
        if (viewState.lastTouchDistance) {
          const scale = distance / viewState.lastTouchDistance;
          viewState.scale *= scale;
          viewState.scale = Math.max(10, Math.min(200, viewState.scale));
          updatePlot();
        }
        viewState.lastTouchDistance = distance;
      }
    });
    
    canvas.addEventListener('touchend', () => {
      viewState.isDragging = false;
      viewState.lastTouchDistance = null;
    });
  }

  // æ˜¾ç¤ºåæ ‡
  function showCoordinates(px, py) {
    const canvas = document.getElementById('mainCanvas');
    const width = canvas.width;
    const height = canvas.height;
    const centerX = width / 2;
    const centerY = height / 2;
    
    const x = (px - centerX) / viewState.scale - viewState.offsetX;
    const y = (centerY - py) / viewState.scale - viewState.offsetY;
    
    const display = document.getElementById('coordinateDisplay');
    display.textContent = `(${x.toFixed(2)}, ${y.toFixed(2)})`;
    display.style.display = 'block';
    display.style.left = Math.min(px + 10, width - 150) + 'px';
    display.style.top = Math.max(py - 30, 10) + 'px';
  }

  // æ”¹å˜å‡½æ•°ç±»å‹
  function changeFunctionType() {
    const type = document.getElementById('functionType').value;
    const def = functionDefinitions[type];
    const container = document.getElementById('parameterControls');
    
    container.innerHTML = '<h4 style="margin-bottom: 1rem; color: var(--secondary); font-size: 0.95rem;">å‚æ•°è°ƒèŠ‚</h4>';
    
    def.params.forEach((param, index) => {
      const sliderContainer = document.createElement('div');
      sliderContainer.className = 'slider-container';
      sliderContainer.innerHTML = `
        <div class="slider-label">
          <span>${param.label}</span>
          <span class="value" id="value_${param.name}">${param.value}</span>
        </div>
        <input type="range" 
               id="param_${param.name}" 
               min="${param.min}" 
               max="${param.max}" 
               step="${param.step}" 
               value="${param.value}"
               oninput="updateParameter('${param.name}', this.value)">
      `;
      container.appendChild(sliderContainer);
    });
    
    // æ›´æ–°é¢„è®¾æŒ‰é’®
    updatePresets(type);
  }

  // æ›´æ–°é¢„è®¾æŒ‰é’®
  function updatePresets(type) {
    const grid = document.getElementById('presetGrid');
    grid.innerHTML = '';
    const typePresets = presets[type] || [];
    typePresets.forEach(preset => {
      const btn = document.createElement('button');
      btn.className = 'preset-btn';
      btn.textContent = preset.name;
      btn.onclick = () => applyPreset(preset.params);
      grid.appendChild(btn);
    });
  }

  // åº”ç”¨é¢„è®¾
  function applyPreset(params) {
    if (functions.length === 0) addFunction();
    const currentFunc = functions[functions.length - 1];
    Object.keys(params).forEach(key => {
      currentFunc.params[key] = params[key];
      const slider = document.getElementById(`param_${key}`);
      const valueDisplay = document.getElementById(`value_${key}`);
      if (slider) {
        slider.value = params[key];
        if (valueDisplay) valueDisplay.textContent = params[key].toFixed(2);
      }
    });
    updatePlot();
  }

  // æ›´æ–°å‚æ•°
  function updateParameter(name, value) {
    if (functions.length === 0) return;
    const currentFunc = functions[functions.length - 1];
    currentFunc.params[name] = parseFloat(value);
    document.getElementById(`value_${name}`).textContent = parseFloat(value).toFixed(2);
    updatePlot();
  }

  // åˆ‡æ¢ç§¯åˆ†æ˜¾ç¤º
  function toggleIntegral() {
    const showIntegral = document.getElementById('showIntegral').checked;
    const container = document.getElementById('integralControls');
    
    if (showIntegral) {
      container.style.display = 'block';
      container.innerHTML = `
        <div class="integral-controls">
          <label style="display: block; margin-bottom: 0.5rem; font-weight: 600;">ç§¯åˆ†åŒºé—´</label>
          <div class="slider-container">
            <div class="slider-label">
              <span>ä¸‹é™ a</span>
              <span class="value" id="value_integral_a">-2</span>
            </div>
            <input type="range" id="param_integral_a" min="-10" max="10" step="0.1" value="-2" oninput="updateIntegral('a', this.value)">
          </div>
          <div class="slider-container">
            <div class="slider-label">
              <span>ä¸Šé™ b</span>
              <span class="value" id="value_integral_b">2</span>
            </div>
            <input type="range" id="param_integral_b" min="-10" max="10" step="0.1" value="2" oninput="updateIntegral('b', this.value)">
          </div>
          <div class="integral-display" id="integralValue">é¢ç§¯: è®¡ç®—ä¸­...</div>
        </div>
      `;
    } else {
      container.style.display = 'none';
    }
    updatePlot();
  }

  // æ›´æ–°ç§¯åˆ†
  function updateIntegral(which, value) {
    document.getElementById(`value_integral_${which}`).textContent = parseFloat(value).toFixed(2);
    updatePlot();
  }

  // æ•°å€¼ç§¯åˆ†ï¼ˆè¾›æ™®æ£®æ³•ï¼‰
  function integrate(func, a, b, n = 1000) {
    if (a >= b) return 0;
    const h = (b - a) / n;
    let sum = 0;
    for (let i = 0; i < n; i++) {
      const x1 = a + i * h;
      const x2 = a + (i + 0.5) * h;
      const x3 = a + (i + 1) * h;
      const y1 = func(x1);
      const y2 = func(x2);
      const y3 = func(x3);
      if (isFinite(y1) && isFinite(y2) && isFinite(y3)) {
        sum += (y1 + 4 * y2 + y3) * h / 6;
      }
    }
    return sum;
  }

  // åˆ‡æ¢åŠ¨ç”»
  function toggleAnimation() {
    isAnimating = !isAnimating;
    const btn = document.getElementById('animationBtn');
    const progress = document.getElementById('animationProgress');
    const progressBar = document.getElementById('animationProgressBar');
    
    if (isAnimating) {
      btn.textContent = 'â¸ï¸ æš‚åœåŠ¨ç”»';
      progress.style.display = 'block';
      startAnimation();
    } else {
      btn.textContent = 'â–¶ï¸ å¼€å§‹åŠ¨ç”»';
      progress.style.display = 'none';
      stopAnimation();
    }
  }

  // å¼€å§‹åŠ¨ç”»
  function startAnimation() {
    if (functions.length === 0) {
      isAnimating = false;
      return;
    }
    
    const currentFunc = functions[functions.length - 1];
    const def = functionDefinitions[currentFunc.type];
    if (def.params.length === 0) {
      isAnimating = false;
      return;
    }
    
    let progress = 0;
    const progressBar = document.getElementById('animationProgressBar');
    
    animationInterval = setInterval(() => {
      if (!isAnimating) return;
      
      const paramIndex = currentParamIndex % def.params.length;
      const param = def.params[paramIndex];
      const currentValue = currentFunc.params[param.name];
      
      let newValue = currentValue + animationDirection * param.step * 2;
      
      if (newValue >= param.max || newValue <= param.min) {
        animationDirection *= -1;
        newValue = Math.max(param.min, Math.min(param.max, newValue));
        currentParamIndex++;
      }
      
      currentFunc.params[param.name] = newValue;
      const slider = document.getElementById(`param_${param.name}`);
      if (slider) {
        slider.value = newValue;
        document.getElementById(`value_${param.name}`).textContent = newValue.toFixed(2);
      }
      
      progress = (progress + 0.5) % 100;
      progressBar.style.width = progress + '%';
      
      updatePlot();
    }, 50);
  }

  // åœæ­¢åŠ¨ç”»
  function stopAnimation() {
    if (animationInterval) {
      clearInterval(animationInterval);
      animationInterval = null;
    }
  }

  // æ·»åŠ å‡½æ•°
  function addFunction() {
    const type = document.getElementById('functionType').value;
    const def = functionDefinitions[type];
    const color = document.getElementById('functionColor').value;
    
    const params = {};
    def.params.forEach(param => {
      params[param.name] = param.value;
    });
    
    functions.push({
      type: type,
      params: params,
      color: color,
      id: Date.now()
    });
    
    updatePlot();
    updateFunctionList();
  }

  // æ›´æ–°å‡½æ•°åˆ—è¡¨
  function updateFunctionList() {
    const list = document.getElementById('functionList');
    list.innerHTML = '';
    
    functions.forEach((func, index) => {
      const def = functionDefinitions[func.type];
      const item = document.createElement('div');
      item.className = 'function-item';
      if (index === functions.length - 1) item.classList.add('active');
      item.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
          <strong>${def.name} #${index + 1}</strong>
          <button onclick="removeFunction(${index})" style="background: var(--accent); color: white; border: none; padding: 0.3rem 0.6rem; border-radius: 6px; cursor: pointer; font-size: 0.8rem;">åˆ é™¤</button>
        </div>
        <div class="function-expression">${def.formula}</div>
        <div style="font-size: 0.85rem; color: var(--text-light); margin-top: 0.5rem;">
          ${def.params.map(p => `${p.label.split(' ')[0]} = ${func.params[p.name].toFixed(2)}`).join(', ')}
        </div>
      `;
      list.appendChild(item);
    });
    
    updateFeaturePoints();
    updateLegend();
  }

  // åˆ é™¤å‡½æ•°
  function removeFunction(index) {
    functions.splice(index, 1);
    updatePlot();
    updateFunctionList();
  }

  // æ›´æ–°ç‰¹å¾ç‚¹
  function updateFeaturePoints() {
    const container = document.getElementById('featurePoints');
    container.innerHTML = '<h4 style="margin-bottom: 1rem; color: var(--secondary); font-size: 0.95rem;">ç‰¹å¾ç‚¹</h4>';
    
    functions.forEach((func, index) => {
      const def = functionDefinitions[func.type];
      const points = def.features(func.params);
      
      points.forEach(point => {
        if (isFinite(point.x) && isFinite(point.y)) {
          const pointDiv = document.createElement('div');
          pointDiv.className = 'feature-point';
          pointDiv.textContent = `å‡½æ•° #${index + 1}: ${point.type} (${point.x.toFixed(2)}, ${point.y.toFixed(2)})`;
          container.appendChild(pointDiv);
        }
      });
    });
  }

  // æ›´æ–°å›¾ä¾‹
  function updateLegend() {
    const legend = document.getElementById('legend');
    legend.innerHTML = '';
    
    functions.forEach((func, index) => {
      const def = functionDefinitions[func.type];
      const item = document.createElement('div');
      item.className = 'legend-item';
      item.innerHTML = `
        <div class="legend-color" style="background: ${func.color};"></div>
        <span>${def.name} #${index + 1}</span>
      `;
      legend.appendChild(item);
    });
    
    if (document.getElementById('showDerivative').checked) {
      functions.forEach((func, index) => {
        const def = functionDefinitions[func.type];
        const item = document.createElement('div');
        item.className = 'legend-item';
        item.innerHTML = `
          <div class="legend-color" style="background: ${func.color}; opacity: 0.5; border-top: 2px dashed ${func.color};"></div>
          <span>${def.name} #${index + 1} å¯¼æ•°</span>
        `;
        legend.appendChild(item);
      });
    }
  }

  // æ›´æ–°ç»˜å›¾
  function updatePlot() {
    if (animationFrame) {
      cancelAnimationFrame(animationFrame);
    }
    
    animationFrame = requestAnimationFrame(() => {
      const canvas = document.getElementById('mainCanvas');
      const ctx = canvas.getContext('2d');
      const width = canvas.width;
      const height = canvas.height;
      
      ctx.clearRect(0, 0, width, height);
      
      const centerX = width / 2;
      const centerY = height / 2;
      const scale = viewState.scale;
      
      // ç»˜åˆ¶ç½‘æ ¼
      if (document.getElementById('showGrid').checked) {
        ctx.strokeStyle = '#E5E7EB';
        ctx.lineWidth = 1;
        
        const startX = Math.floor((-centerX / scale - viewState.offsetX) / 1) * 1;
        const endX = Math.ceil((centerX / scale - viewState.offsetX) / 1) * 1;
        const startY = Math.floor((-centerY / scale - viewState.offsetY) / 1) * 1;
        const endY = Math.ceil((centerY / scale - viewState.offsetY) / 1) * 1;
        
        for (let x = startX; x <= endX; x += 1) {
          const px = centerX + (x + viewState.offsetX) * scale;
          ctx.beginPath();
          ctx.moveTo(px, 0);
          ctx.lineTo(px, height);
          ctx.stroke();
        }
        
        for (let y = startY; y <= endY; y += 1) {
          const py = centerY - (y + viewState.offsetY) * scale;
          ctx.beginPath();
          ctx.moveTo(0, py);
          ctx.lineTo(width, py);
          ctx.stroke();
        }
      }
      
      // ç»˜åˆ¶åæ ‡è½´
      if (document.getElementById('showAxes').checked) {
        ctx.strokeStyle = '#374151';
        ctx.lineWidth = 2;
        
        // Xè½´
        const yAxis = centerY - viewState.offsetY * scale;
        if (yAxis >= 0 && yAxis <= height) {
          ctx.beginPath();
          ctx.moveTo(0, yAxis);
          ctx.lineTo(width, yAxis);
          ctx.stroke();
          
          // Xè½´æ ‡ç­¾å’Œåˆ»åº¦
          if (document.getElementById('showLabels').checked) {
            ctx.fillStyle = '#374151';
            ctx.font = '12px Arial';
            const startX = Math.floor((-centerX / scale - viewState.offsetX) / 1) * 1;
            const endX = Math.ceil((centerX / scale - viewState.offsetX) / 1) * 1;
            for (let x = startX; x <= endX; x += 1) {
              if (x !== 0) {
                const px = centerX + (x + viewState.offsetX) * scale;
                ctx.beginPath();
                ctx.moveTo(px, yAxis - 5);
                ctx.lineTo(px, yAxis + 5);
                ctx.stroke();
                ctx.fillText(x.toString(), px - 5, yAxis + 18);
              }
            }
          }
        }
        
        // Yè½´
        const xAxis = centerX + viewState.offsetX * scale;
        if (xAxis >= 0 && xAxis <= width) {
          ctx.beginPath();
          ctx.moveTo(xAxis, 0);
          ctx.lineTo(xAxis, height);
          ctx.stroke();
          
          // Yè½´æ ‡ç­¾å’Œåˆ»åº¦
          if (document.getElementById('showLabels').checked) {
            ctx.fillStyle = '#374151';
            ctx.font = '12px Arial';
            const startY = Math.floor((-centerY / scale - viewState.offsetY) / 1) * 1;
            const endY = Math.ceil((centerY / scale - viewState.offsetY) / 1) * 1;
            for (let y = startY; y <= endY; y += 1) {
              if (y !== 0) {
                const py = centerY - (y + viewState.offsetY) * scale;
                ctx.beginPath();
                ctx.moveTo(xAxis - 5, py);
                ctx.lineTo(xAxis + 5, py);
                ctx.stroke();
                ctx.fillText(y.toString(), xAxis + 10, py + 4);
              }
            }
          }
        }
      }
      
      // ç»˜åˆ¶ç§¯åˆ†é¢ç§¯
      if (document.getElementById('showIntegral') && document.getElementById('showIntegral').checked && functions.length > 0) {
        const integralA = parseFloat(document.getElementById('param_integral_a')?.value || -2);
        const integralB = parseFloat(document.getElementById('param_integral_b')?.value || 2);
        const func = functions[functions.length - 1];
        const def = functionDefinitions[func.type];
        
        if (integralA < integralB) {
          ctx.fillStyle = func.color;
          ctx.globalAlpha = 0.3;
          ctx.beginPath();
          
          const pa = centerX + (integralA + viewState.offsetX) * scale;
          const pb = centerX + (integralB + viewState.offsetX) * scale;
          const step = 1 / scale;
          
          let firstPoint = true;
          for (let x = integralA; x <= integralB; x += step) {
            const y = def.eval(x, func.params);
            if (isFinite(y) && !isNaN(y)) {
              const px = centerX + (x + viewState.offsetX) * scale;
              const py = centerY - (y + viewState.offsetY) * scale;
              
              if (firstPoint) {
                ctx.moveTo(px, centerY - viewState.offsetY * scale);
                ctx.lineTo(px, py);
                firstPoint = false;
              } else {
                ctx.lineTo(px, py);
              }
            }
          }
          
          const pyEnd = centerY - (def.eval(integralB, func.params) + viewState.offsetY) * scale;
          ctx.lineTo(pb, centerY - viewState.offsetY * scale);
          ctx.closePath();
          ctx.fill();
          ctx.globalAlpha = 1;
          
          // è®¡ç®—å¹¶æ˜¾ç¤ºç§¯åˆ†å€¼
          const area = integrate((x) => def.eval(x, func.params), integralA, integralB);
          document.getElementById('integralValue').textContent = `é¢ç§¯ â‰ˆ ${area.toFixed(4)}`;
        }
      }
      
      // ç»˜åˆ¶å‡½æ•°
      functions.forEach(func => {
        const def = functionDefinitions[func.type];
        
        // ç»˜åˆ¶åŸå‡½æ•°ï¼ˆä½¿ç”¨å¹³æ»‘æ›²çº¿ï¼‰
        ctx.strokeStyle = func.color;
        ctx.lineWidth = 3;
        ctx.beginPath();
        
        let firstPoint = true;
        const step = 1 / scale;
        const startX = -centerX / scale - viewState.offsetX;
        const endX = centerX / scale - viewState.offsetX;
        let lastX = null, lastY = null;
        
        for (let x = startX; x <= endX; x += step) {
          const y = def.eval(x, func.params);
          if (isFinite(y) && !isNaN(y)) {
            const px = centerX + (x + viewState.offsetX) * scale;
            const py = centerY - (y + viewState.offsetY) * scale;
            
            if (py >= -50 && py <= height + 50) {
              if (firstPoint) {
                ctx.moveTo(px, py);
                firstPoint = false;
                lastX = px;
                lastY = py;
              } else {
                // ä½¿ç”¨äºŒæ¬¡è´å¡å°”æ›²çº¿å®ç°å¹³æ»‘
                const midX = (lastX + px) / 2;
                const midY = (lastY + py) / 2;
                ctx.quadraticCurveTo(lastX, lastY, midX, midY);
                lastX = px;
                lastY = py;
              }
            } else {
              firstPoint = true;
              lastX = null;
              lastY = null;
            }
          } else {
            firstPoint = true;
            lastX = null;
            lastY = null;
          }
        }
        if (lastX !== null && lastY !== null) {
          ctx.lineTo(lastX, lastY);
        }
        ctx.stroke();
        
        // ç»˜åˆ¶å¯¼æ•°
        if (document.getElementById('showDerivative').checked) {
          ctx.strokeStyle = func.color;
          ctx.globalAlpha = 0.6;
          ctx.lineWidth = 2;
          ctx.setLineDash([5, 5]);
          ctx.beginPath();
          
          firstPoint = true;
          lastX = null;
          lastY = null;
          
          for (let x = startX; x <= endX; x += step) {
            const y = def.derivative(x, func.params);
            if (isFinite(y) && !isNaN(y)) {
              const px = centerX + (x + viewState.offsetX) * scale;
              const py = centerY - (y + viewState.offsetY) * scale;
              
              if (py >= -50 && py <= height + 50) {
                if (firstPoint) {
                  ctx.moveTo(px, py);
                  firstPoint = false;
                  lastX = px;
                  lastY = py;
                } else {
                  const midX = (lastX + px) / 2;
                  const midY = (lastY + py) / 2;
                  ctx.quadraticCurveTo(lastX, lastY, midX, midY);
                  lastX = px;
                  lastY = py;
                }
              } else {
                firstPoint = true;
                lastX = null;
                lastY = null;
              }
            } else {
              firstPoint = true;
              lastX = null;
              lastY = null;
            }
          }
          if (lastX !== null && lastY !== null) {
            ctx.lineTo(lastX, lastY);
          }
          ctx.stroke();
          ctx.setLineDash([]);
          ctx.globalAlpha = 1;
        }
        
        // ç»˜åˆ¶ç‰¹å¾ç‚¹ï¼ˆå¸¦åŠ¨ç”»æ•ˆæœï¼‰
        if (document.getElementById('showPoints').checked) {
          const points = def.features(func.params);
          points.forEach(point => {
            if (isFinite(point.x) && isFinite(point.y)) {
              const px = centerX + (point.x + viewState.offsetX) * scale;
              const py = centerY - (point.y + viewState.offsetY) * scale;
              
              if (px >= 0 && px <= width && py >= 0 && py <= height) {
                // å¤–åœˆåŠ¨ç”»
                ctx.strokeStyle = func.color;
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.3;
                for (let r = 8; r <= 16; r += 4) {
                  ctx.beginPath();
                  ctx.arc(px, py, r, 0, 2 * Math.PI);
                  ctx.stroke();
                }
                ctx.globalAlpha = 1;
                
                // ä¸­å¿ƒç‚¹
                ctx.fillStyle = func.color;
                ctx.beginPath();
                ctx.arc(px, py, 6, 0, 2 * Math.PI);
                ctx.fill();
                
                // ç™½è‰²è¾¹æ¡†
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                if (document.getElementById('showLabels').checked) {
                  ctx.fillStyle = '#374151';
                  ctx.font = '10px Arial';
                  ctx.fillText(`${point.type}`, px + 10, py - 10);
                }
              }
            }
          });
        }
      });
    });
  }

  // è§†å›¾æ§åˆ¶
  function zoomIn() {
    viewState.scale *= 1.2;
    viewState.scale = Math.min(200, viewState.scale);
    updatePlot();
  }

  function zoomOut() {
    viewState.scale *= 0.8;
    viewState.scale = Math.max(10, viewState.scale);
    updatePlot();
  }

  function resetView() {
    viewState.scale = 50;
    viewState.offsetX = 0;
    viewState.offsetY = 0;
    updatePlot();
  }

  function clearAll() {
    if (confirm('ç¡®å®šè¦æ¸…é™¤æ‰€æœ‰å‡½æ•°å—ï¼Ÿ')) {
      functions = [];
      stopAnimation();
      isAnimating = false;
      document.getElementById('animationBtn').textContent = 'â–¶ï¸ å¼€å§‹åŠ¨ç”»';
      document.getElementById('animationProgress').style.display = 'none';
      updatePlot();
      updateFunctionList();
    }
  }

  // ä¿å­˜æˆªå›¾
  function saveScreenshot() {
    const canvas = document.getElementById('mainCanvas');
    const link = document.createElement('a');
    link.download = `å‡½æ•°å›¾åƒ_${new Date().getTime()}.png`;
    link.href = canvas.toDataURL('image/png');
    link.click();
  }

  // é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–
  window.addEventListener('load', init);
</script>
</body>
</html>